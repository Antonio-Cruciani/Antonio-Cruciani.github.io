<!DOCTYPE html>
<!--
    Plain-Academic by Vasilios Mavroudis
    Released under the Simplified BSD License/FreeBSD (2-clause) License.
    https://github.com/mavroudisv/plain-academic
-->

<html lang="en">
<head>
  <title>Antonio Cruciani</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.0/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
  <link href='https://fonts.googleapis.com/css?family=Oswald:700' rel='stylesheet' type='text/css'>
</head>
<body>


<!-- Navigation -->
	<nav class="navbar navbar-inverse navbar-static-top" role="navigation">
	  <div class="container">
		<div class="navbar-header">
		  <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
						<span class="sr-only">Toggle navigation</span>
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
					</button>
		</div>

		<!-- Collect the nav links, forms, and other content for toggling -->
		<div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
		  <ul class="nav navbar-nav">
				  <li><a href="index.html">Home</a></li>
                  <li><a href="research.html">Research</a></li> 
                  <li><a href="talks.html">Talks</a></li> 
                  <li><a href="projects.html">Projects</a></li> 
                  <li><a href="code.html">Code</a></li> 
                  <li><a href="cv.html">CV</a></li> 
                  <li><a href="teachings.html">Teachings</a></li> 



		  </ul>
		</div>
	  </div>
	</nav>
  
  <!-- Page Content -->
    <div class="container">
        <div class="row">
            <div class="col-md-8" style="height: 45vh;">
                <img class="img-responsive" src="photo.png" width="300" height="300" alt=""><br>

            </div>
            <!-- Contact Info on the Sidebar -->
            <div class="col-md-4">
                <div style="font-family: 'Oswald', sans-serif; font-size: 32px;"><b>Antonio Cruciani</b></div><br>
                <p><b>#name.#surname AT gssi.it</b><br>
                <b><a href="antonio_cruciani.asc">OpenPGP</a></b><br>
                <p>Computer Science<br>
                Gran Sasso Science Institute<br>
                Viale Francesco Crispi, 7<br>
                L'Aquila <br>
                Italy<br>
                </p>
            </div>
            
            
            <!-- Links on the Sidebar -->
            <div class="col-md-4" style="margin-top:2%">
              <dd><a href="https://dblp.org/pid/249/5159">dblp</a></dd> 
              <dd><a href="https://github.com/Antonio-Cruciani">Github</a></dd>
              <dd><a href="https://linkedin.com/in/antonio-cruciani-9b7b7083">LinkedIn</a></dd>
            </div>
        </div>

        <div class="row">

            <!-- Entries Column -->
            <div class="col-md-8" style="height:30vh;">
                
                 <table>
                    <tr>
                    <th><h3> Code </h3></th>
                    <tr> 
                        <td>
                        <ul>
                            <li><h4>FEPiC: Fast Estimation of Percolation Centrality. <a href="https://github.com/Antonio-Cruciani/percolation_centrality">[Code]</a></h4>
                                FEPic is a progressive sampling based algorithm to approximate the percolation centrality of all nodes in a static graph. FEPiC uses Monte Carlo Empirical Rademacher Averages and variance aware bounds for the sample complexity to provide a high quality approximation of such a centrality measure. FEPiC extends the novel algorithm for the Betweenness Centrality by <a href="https://dl.acm.org/doi/10.1145/3628601">[Pellegrina and Vandin]</a > to the Percolation Centrality. FEPiC is the best choice in terms of sample size, running time and quality of the approximation. The Julia library includes efficient (parallel) implementation of: (i) FEPiC (see <a href="https://arxiv.org/abs/2408.02389"> [arXiv]</a> for the original paper); (ii) the progressive sampling algorithm by <a href="https://www.sciencedirect.com/science/article/pii/S0166218X21002821?via%3Dihub">[Lima et al.]</a>; (iii) the fixed sample size algorithm by <a href="https://dl.acm.org/doi/10.1145/3394486.3403235">[Lima et al.]</a>; and, an efficient version of the exact algorithm for the percolation centality. All the algorithms use multithreading and outperforms the already existing NetowkrX implementations. 
                                

                            </li>
                            <li><h4>MANTRA: Temporal Betweenness Centrality Approximation through Sampling.  <a href="https://github.com/Antonio-Cruciani/MANTRA">[Code]</a></h4>
                            MANTRA is a progressive sampling based algorithm to approximate the temporal betweenness centrality of all nodes in a temporal graph. MANTRA uses Monte Carlo Empirical Rademacher Averages and variance aware results on sample complexity to provide a high quality approximation of the Shortest (Foremost) and Prefix Foremost Temporal Betweenness centralities <a href="https://dl.acm.org/doi/10.1145/3394486.3403259">[Buß et al.]</a>. MANTRA is the best choice in terms of sample size, running time, and required space (linear in the size of the temproal graph) to provide high quality approximations of the temporal betweenness centrality. Furthermore, our framework can be easily extended to compute the temporal betwenness centrality of the temporal edges and thus provide fast and accurate clustering algorithms for temporal networks. In addition, our library includes a novel sampling-based approximation algorithm for the temporal (effective) diameter, average path length, and temporal connectivity rate for the temporal optimality criteria considered in our work (see <a href="https://arxiv.org/abs/2304.08356"> [arXiv]</a>). The Julia library includes efficient (parallel) implementations of: (i) our algorithms; (ii) a progressive sampling version of ONBRA <a href="https://dl.acm.org/doi/10.1145/3485447.3512204">[Santoro et al.]</a> (extended to all the temporal path optimalities mentioned above); and, (iii) the exact algorithms in <a href="https://dl.acm.org/doi/10.1145/3394486.3403259">[Buß et al.]</a>. Moreover, we fixed the issues with the original versions of the exact algorithms and ONBRA (see <a href="https://arxiv.org/abs/2304.08356"> [arXiv]</a>) that lead to overflows (on temporal networks with high number of temporal paths), underestimation of the centrality scores, and memory overflows. Indeed, our efficient parallel implementation of the exact algorithms can be usded to compute the exact temporal betweenness scores on huge temporal graphs. 
                            </li>
                            <li><h4>PROPAGATE: a seed propagation framework to compute Distance-based metrics on Very Large Graphs.  <a href="https://github.com/BigDataLaboratory/MHSE">[Code]</a></h4>
                            PROPAGATE is a sampling based algorithm to approximate all the distance-based metrics (diameter, effective diameter, average distance, number of reachable pairs, connectivity rate, and geometric centralities (closeness, harmonic,lin). The Java library includes two efficient approximation algorithms (see <a href="https://arxiv.org/abs/2301.06499">[arXiv]</a>). PROPAGATE is the best choice in terms of running time and required space (linear in the size of the graph) to provide high quality approximations of the aforementioned quantities.
                            The framework outperform the state of the art in approximating distance metrics.
                            </li>
                            <li><h4>TSBProxy:Temporal Shortest Betweenness Proxy. <a href="https://github.com/Antonio-Cruciani/TSBProxy">[Code]</a></h4>
                            TSBProxy is a suite of Proxies for the Temporal Shortest Betweennes Centrality. The suite includes efficient Julia (single thread) implementations of the Shortest Temporal and Prefix Foremost Temporal Betweenness algorithms <a href="https://dl.acm.org/doi/10.1145/3394486.3403259">[Buß et al.]</a>, their Ego-Temporal Betweennes versions, ONBRA algorithm (for the Shortest Temporal Betweenness) <a href="https://dl.acm.org/doi/10.1145/3485447.3512204">[Santoro et al.]</a>, and a novel notion of Temporal Degree that can be used as a proxy for the Shortest Temporal Betweenness rankings.
                             </li>
                            <li> <h4>  DREG:Dynamic Random Expander Generator. <a href="https://github.com/Antonio-Cruciani/DREG-DynamicRandomExpanderGenerator/tree/master">[Code]</a></h4>
                              DREG is a Python implementation of a generator that produces almost regular dynamic random graphs (or random temporal graphs) that are expander graphs at each round (time) with high probability.
                            </li>
                        
                        
                      
                   </ul>
                       </th>
                    </tr>
                    
                 </table>
         
            </div> 



            
            
            


            
        </div>

        


        </div>



    </div>
    <!-- /.container -->
    
    <!-- Other people may like it too! -->

   <!-- <a style="color:#b5bec9;font-size:0.8em; float:right;" href="https://github.com/mavroudisv/plain-academic">Plain Academic</a> -->
    
</body>

</html>
